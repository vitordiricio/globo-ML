import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import statsmodels.api as sm

def analise_externos(df):
    """
    Analyzes external factors' impact on TV Linear data, including economic indicators,
    specific events, and social metrics.
    
    Args:
        df (DataFrame): Processed dataframe with EXTERNO_* prefixed columns
    """

    st.header("üìä Fatores Externos - Impacto na Audi√™ncia")

    # 1. Header section with last update date
    if 'data_hora' in df.columns:
        last_date = df['data_hora'].max()
        if isinstance(last_date, pd.Timestamp):
            last_date = last_date.to_pydatetime()
        st.caption(f"√öltima atualiza√ß√£o: {last_date.strftime('%d/%m/%Y')}")

    # Ensure data_hora is datetime type
    if 'data_hora' in df.columns and not pd.api.types.is_datetime64_dtype(df['data_hora']):
        df['data_hora'] = pd.to_datetime(df['data_hora'])

    # Create copies of the dataframe for each granularity
    # Use original dataframe for hourly analysis
    df_hourly = df.copy()

    # Create daily aggregation
    df_daily = df.copy()
    df_daily['data'] = df_daily['data_hora'].dt.date

    # Filter numeric columns for aggregation (to avoid categorical type error)
    numeric_cols = df_daily.select_dtypes(include=['number']).columns.tolist()
    if 'data' in numeric_cols:
        numeric_cols.remove('data')

    # Group by date for numeric columns only
    df_daily = df_daily.groupby('data')[numeric_cols].mean().reset_index()
    df_daily['data_hora'] = pd.to_datetime(df_daily['data'])

    # Create weekly aggregation
    df_weekly = df.copy()
    df_weekly['semana'] = df_weekly['data_hora'].dt.to_period('W').astype(str)

    # Group by week for numeric columns only
    df_weekly = df_weekly.groupby('semana')[numeric_cols].mean().reset_index()
    df_weekly['data_hora'] = pd.to_datetime(df_weekly['semana'].str.split('/').str[0])

    # 2. Granularity Selection
    st.markdown("""
    ### An√°lise de Fatores Externos

    Esta an√°lise explora como fatores externos impactam a audi√™ncia da TV Linear da Globo. 
    Investigamos cinco categorias principais:

    1. **Indicadores Econ√¥micos**: Como infla√ß√£o, desemprego e outros √≠ndices econ√¥micos se correlacionam com o comportamento da audi√™ncia
    2. **Programas Recorrentes**: Analisamos como programas recorrentes (novelas, reality shows, futebol) influenciam a audi√™ncia
    3. **G√™neros de Programa√ß√£o**: Como diferentes g√™neros televisivos impactam a audi√™ncia
    4. **Eventos Isolados**: O impacto de eventos pontuais como not√≠cias importantes, lan√ßamentos, etc.
    5. **Volume Social**: Como o volume de conversas nas redes sociais se relaciona com a audi√™ncia TV

    Estas an√°lises ajudam a contextualizar o desempenho da TV Linear dentro do ambiente competitivo.

    **Dica**: A an√°lise por hora √© especialmente √∫til para entender o impacto de eventos espec√≠ficos que ocorrem em hor√°rios determinados, como jogos de futebol ou programas de TV concorrentes.
    """)

    granularity = st.selectbox(
        "Selecione a granularidade:",
        options=["Hor√°rio", "Di√°rio", "Semanal"],
        index=0  # Default to "Hor√°rio"
    )

    # Get the selected dataframe
    if granularity == "Di√°rio":
        selected_df = df_daily
    elif granularity == "Semanal":
        selected_df = df_weekly
    else:  # "Hor√°rio"
        selected_df = df_hourly

    # Identify the TV column to use (audience metric)
    tv_col = 'LINEAR_GLOBO_cov%' if 'LINEAR_GLOBO_cov%' in selected_df.columns else None

    if tv_col is None:
        st.error("N√£o foi poss√≠vel encontrar a coluna 'LINEAR_GLOBO_cov%' no conjunto de dados.")
        return

    # Create tabs for different categories of analysis
    tabs = st.tabs(["Indicadores Econ√¥micos", "Programas Recorrentes", "G√™neros de Programa√ß√£o", "Eventos Isolados", "Volume Social", "Resumo"])

    #######################################
    # 3. Economic Indicators Analysis Tab #
    #######################################
    with tabs[0]:
        st.subheader("An√°lise de Indicadores Econ√¥micos")
        
        st.markdown("""
        Os indicadores econ√¥micos podem influenciar significativamente os h√°bitos de consumo de m√≠dia.
        Por exemplo, em per√≠odos de maior desemprego, as pessoas podem passar mais tempo em casa assistindo TV,
        enquanto infla√ß√£o alta pode levar √† redu√ß√£o de gastos com entretenimento pago.
        
        O gr√°fico abaixo mostra a evolu√ß√£o dos principais indicadores econ√¥micos normalizados comparados
        com a evolu√ß√£o da audi√™ncia TV Linear da Globo.
        """)
        
        # Find economic indicator columns based on new naming pattern
        economic_cols = [col for col in selected_df.columns if col.startswith('EXTERNO_ECONOMICO_')]
        
        if economic_cols and tv_col:
            # Filter data where both economic indicators and tv_col have valid values
            valid_eco_data = selected_df.dropna(subset=economic_cols + [tv_col])
            
            if not valid_eco_data.empty:
                # Create time series chart comparing economic indicators with TV audience
                fig = make_subplots(specs=[[{"secondary_y": True}]])
                
                # Add TV audience line
                fig.add_trace(
                    go.Scatter(
                        x=valid_eco_data['data_hora'],
                        y=valid_eco_data[tv_col],
                        name='Audi√™ncia TV Globo (cov%)',
                        line=dict(color='rgb(31, 119, 180)', width=3)
                    ),
                    secondary_y=False
                )
                
                # Add economic indicators (normalized)
                colors = ['rgb(255, 127, 14)', 'rgb(44, 160, 44)', 'rgb(214, 39, 40)', 
                        'rgb(148, 103, 189)', 'rgb(140, 86, 75)']
                
                for i, col in enumerate(economic_cols):
                    # Only include columns with valid data
                    if not valid_eco_data[col].isna().all():
                        # Normalize the indicator for better visualization
                        min_val = valid_eco_data[col].min()
                        max_val = valid_eco_data[col].max()
                        if max_val > min_val:  # Avoid division by zero
                            normalized = (valid_eco_data[col] - min_val) / (max_val - min_val) * valid_eco_data[tv_col].max()
                            
                            # Clean up column name for display
                            display_name = col.replace('EXTERNO_ECONOMICO_', '').replace('_', ' ').title()
                            
                            fig.add_trace(
                                go.Scatter(
                                    x=valid_eco_data['data_hora'],
                                    y=normalized,
                                    name=display_name,
                                    line=dict(color=colors[i % len(colors)], dash='dash')
                                ),
                                secondary_y=True
                            )
                
                # Update layout
                fig.update_layout(
                    title=f'Evolu√ß√£o da Audi√™ncia TV vs. Indicadores Econ√¥micos ({granularity})',
                    xaxis_title='Data',
                    yaxis_title='Audi√™ncia TV Globo (cov%)',
                    yaxis2_title='Indicadores (Normalizados)',
                    legend_title='M√©tricas',
                    hovermode="x unified"
                )
                
                st.plotly_chart(fig, use_container_width=True)
                
                # Create correlation matrix between economic indicators and audience metrics
                st.markdown("### Correla√ß√£o entre Indicadores Econ√¥micos e M√©tricas de Audi√™ncia")
                
                st.markdown("""
                A tabela abaixo mostra a correla√ß√£o entre diferentes indicadores econ√¥micos e m√©tricas de audi√™ncia TV.
                Uma correla√ß√£o positiva (pr√≥xima de 1) indica que as vari√°veis tendem a aumentar juntas,
                enquanto uma correla√ß√£o negativa (pr√≥xima de -1) indica uma rela√ß√£o inversa.
                Valores pr√≥ximos de zero indicam pouca ou nenhuma rela√ß√£o linear.
                """)
                
                # Select audience metrics
                audience_metrics = [col for col in valid_eco_data.columns if col.startswith('LINEAR_GLOBO_') 
                                and col in ['LINEAR_GLOBO_cov%', 'LINEAR_GLOBO_shr%', 'LINEAR_GLOBO_tvr%']]
                
                if audience_metrics:
                    # Calculate correlation matrix
                    corr_matrix = valid_eco_data[economic_cols + audience_metrics].corr()
                    
                    # Extract correlations between economic indicators and audience metrics
                    eco_audience_corr = corr_matrix.loc[economic_cols, audience_metrics]
                    
                    # Create a clean correlation matrix for display
                    clean_rows = [col.replace('EXTERNO_ECONOMICO_', '').replace('_', ' ').title() for col in eco_audience_corr.index]
                    clean_cols = [col.replace('LINEAR_GLOBO_', '').replace('%', ' %') for col in eco_audience_corr.columns]
                    
                    clean_corr = pd.DataFrame(
                        eco_audience_corr.values,
                        index=clean_rows,
                        columns=clean_cols
                    )
                    
                    # Create heatmap
                    fig_heatmap = px.imshow(
                        clean_corr,
                        text_auto=True,
                        aspect="auto",
                        color_continuous_scale=["red", "white", "green"],
                        labels=dict(x="M√©trica de Audi√™ncia Globo", y="Indicador Econ√¥mico", color="Correla√ß√£o"),
                        title="Correla√ß√£o entre Indicadores Econ√¥micos e M√©tricas de Audi√™ncia"
                    )
                    
                    st.plotly_chart(fig_heatmap, use_container_width=True)
                    
                    # Generate insights based on correlations
                    st.markdown("### Insights Principais")
                    
                    # Find strongest positive and negative correlations
                    eco_audience_flat = eco_audience_corr.unstack()
                    strongest_positive = eco_audience_flat.nlargest(1)
                    strongest_negative = eco_audience_flat.nsmallest(1)
                    
                    # Display insights
                    if not strongest_positive.empty:
                        pos_val = strongest_positive.values[0]
                        pos_idx = strongest_positive.index[0]
                        pos_eco = pos_idx[0].replace('EXTERNO_ECONOMICO_', '').replace('_', ' ').title()
                        pos_aud = pos_idx[1].replace('LINEAR_GLOBO_', '').replace('%', ' %')
                        
                        if pos_val > 0.3:
                            st.success(f"**Rela√ß√£o Positiva Forte:** {pos_eco} tem correla√ß√£o positiva de {pos_val:.2f} com {pos_aud}, "
                                    f"sugerindo que aumentos neste indicador est√£o associados a maiores n√≠veis de audi√™ncia da Globo.")
                    
                    if not strongest_negative.empty:
                        neg_val = strongest_negative.values[0]
                        neg_idx = strongest_negative.index[0]
                        neg_eco = neg_idx[0].replace('EXTERNO_ECONOMICO_', '').replace('_', ' ').title()
                        neg_aud = neg_idx[1].replace('LINEAR_GLOBO_', '').replace('%', ' %')
                        
                        if neg_val < -0.3:
                            st.error(f"**Rela√ß√£o Negativa Forte:** {neg_eco} tem correla√ß√£o negativa de {neg_val:.2f} com {pos_aud}, "
                                f"sugerindo que aumentos neste indicador est√£o associados a menores n√≠veis de audi√™ncia da Globo.")
                    
                    # Additional insights based on specific economic indicators
                    unemployment_col = [col for col in economic_cols if 'unemployment' in col.lower()]
                    if unemployment_col and audience_metrics:
                        unemp_col = unemployment_col[0]
                        unemp_corr = corr_matrix.loc[unemp_col, tv_col]
                        
                        if abs(unemp_corr) > 0.3:
                            direction = "positiva" if unemp_corr > 0 else "negativa"
                            impact = "maior" if unemp_corr > 0 else "menor"
                            reason = "mais pessoas em casa e/ou a busca por entretenimento de menor custo" if unemp_corr > 0 else "mudan√ßa para alternativas de entretenimento mais econ√¥micas"
                            
                            st.info(f"**Desemprego e Audi√™ncia:** A correla√ß√£o {direction} de {unemp_corr:.2f} entre desemprego e audi√™ncia "
                                f"sugere que em per√≠odos de maior desemprego h√° {impact} consumo de TV Linear Globo, possivelmente "
                                f"devido a {reason}.")
                    
                    inflation_col = [col for col in economic_cols if 'inflation' in col.lower()]
                    if inflation_col and audience_metrics:
                        infl_col = inflation_col[0]
                        infl_corr = corr_matrix.loc[infl_col, tv_col]
                        
                        if abs(infl_corr) > 0.3:
                            dir_word = "maior" if infl_corr > 0 else "menor"
                            st.info(f"**Infla√ß√£o e Audi√™ncia:** A correla√ß√£o de {infl_corr:.2f} entre infla√ß√£o (IPCA) e audi√™ncia "
                                f"sugere que per√≠odos de infla√ß√£o mais alta est√£o associados a {dir_word} consumo de TV Linear Globo.")
            else:
                st.warning("Dados insuficientes para an√°lise de indicadores econ√¥micos.")
        else:
            st.warning("Dados econ√¥micos ou de audi√™ncia n√£o est√£o dispon√≠veis.")

    ########################################
    # 4. Recurring Programs Analysis Tab   #
    ########################################
    with tabs[1]:
        st.subheader("An√°lise de Programas Recorrentes")
        
        st.markdown("""
        Programas recorrentes como novelas, reality shows e jogos de futebol podem ter impacto significativo
        na audi√™ncia da TV Globo, tanto os transmitidos pela pr√≥pria Globo quanto os exibidos por emissoras concorrentes.
        
        Esta an√°lise permite observar como programas recorrentes de emissoras concorrentes podem "roubar" audi√™ncia da TV Globo,
        ou como programas da pr√≥pria Globo tendem a aumentar sua audi√™ncia.
        """)
        
        # Find columns for recurring programs
        recorrente_cols = [col for col in selected_df.columns if col.startswith('EXTERNO_GRADE_RECORRENTE_')]
        
        if recorrente_cols and tv_col:
            # Extract unique program types from column names
            # The program type is in the 4th position when splitting by '_'
            program_types = set()
            for col in recorrente_cols:
                parts = col.split('_')
                if len(parts) >= 5:  # Ensure we have enough parts
                    program_types.add(parts[4])  # Extract program type (4th element)
            
            program_types = sorted(list(program_types))
            
            if program_types:
                # Let user select a program type to analyze
                selected_program = st.selectbox(
                    "Selecione um programa para an√°lise:",
                    options=program_types
                )
                
                # Get all columns related to the selected program
                program_cols = [col for col in recorrente_cols if f"_{selected_program}_" in col]
                
                if program_cols:
                    # Extract broadcaster from each column
                    broadcasters = []
                    for col in program_cols:
                        parts = col.split('_')
                        if len(parts) >= 6:  # Ensure we have enough parts
                            broadcasters.append(parts[3])  # Extract broadcaster (5th element)
                    
                    st.markdown(f"### Impacto do Programa {selected_program} na Audi√™ncia da TV Globo")
                    
                    # Calculate impact for each broadcaster
                    impact_data = []
                    
                    for col in program_cols:
                        # Extract broadcaster name
                        parts = col.split('_')
                        broadcaster = parts[3] if len(parts) >= 6 else "Unknown"
                        
                        # Calculate audience with and without program
                        valid_data = selected_df.dropna(subset=[col, tv_col])
                        if valid_data.empty or valid_data[col].sum() == 0:
                            continue
                            
                        program_on = valid_data[valid_data[col] > 0][tv_col].mean()
                        program_off = valid_data[valid_data[col] == 0][tv_col].mean()
                        
                        # Calculate impact percentage
                        if program_off > 0:  # Avoid division by zero
                            impact_pct = ((program_on / program_off) - 1) * 100
                            
                            # Count occurrences
                            occurrences = valid_data[valid_data[col] > 0].shape[0]
                            
                            relation_type = "pr√≥pria" if broadcaster == "GLOBO" else "concorrente"
                            
                            impact_data.append({
                                "Programa": selected_program,
                                "Emissora": broadcaster,
                                "Tipo": relation_type,
                                "Impacto (%)": impact_pct,
                                "Dire√ß√£o": "Positivo" if impact_pct > 0 else "Negativo",
                                "Ocorr√™ncias": occurrences
                            })
                    
                    if impact_data:
                        # Convert to DataFrame and format
                        impact_df = pd.DataFrame(impact_data)
                        
                        # Create a key insight about this program's impact
                        if "GLOBO" in impact_df["Emissora"].values:
                            globo_impact = impact_df[impact_df["Emissora"] == "GLOBO"]["Impacto (%)"].values[0]
                            direction = "aumenta" if globo_impact > 0 else "reduz"
                            
                            st.info(f"**{selected_program} na Globo:** Quando exibido na pr√≥pria Globo, este programa {direction} "
                                  f"a audi√™ncia da emissora em {abs(globo_impact):.2f}% em m√©dia.")
                        
                        # Find competitors with biggest impact
                        competitors = impact_df[impact_df["Emissora"] != "GLOBO"]
                        if not competitors.empty:
                            strongest_competitor = competitors.loc[competitors["Impacto (%)"].abs().idxmax()]
                            comp_direction = "aumenta" if strongest_competitor["Impacto (%)"] > 0 else "reduz"
                            
                            st.warning(f"**{selected_program} na {strongest_competitor['Emissora']}:** Quando exibido nesta emissora concorrente, "
                                     f"{comp_direction} a audi√™ncia da Globo em {abs(strongest_competitor['Impacto (%)']):.2f}% em m√©dia.")
                            
                            if strongest_competitor["Impacto (%)"] < 0:
                                st.error(f"üëâ Isso sugere que o programa {selected_program} na {strongest_competitor['Emissora']} est√° "
                                       f"'roubando' audi√™ncia da TV Globo, potencialmente atraindo seus telespectadores.")
                        
                        # Create a bar chart comparing impact across broadcasters
                        impact_df["Impacto Formatado"] = impact_df["Impacto (%)"].apply(lambda x: f"{x:.2f}%")
                        
                        # Add a special color for Globo vs competitors
                        color_map = {"pr√≥pria": "green", "concorrente": "red"}
                        
                        fig = px.bar(
                            impact_df,
                            x="Emissora",
                            y="Impacto (%)",
                            color="Tipo",
                            text="Impacto Formatado",
                            title=f"Impacto do {selected_program} na Audi√™ncia da TV Globo por Emissora",
                            color_discrete_map=color_map,
                            hover_data=["Ocorr√™ncias"]
                        )
                        
                        fig.update_layout(
                            xaxis_title="Emissora",
                            yaxis_title="Impacto na Audi√™ncia da Globo (%)",
                            yaxis=dict(zeroline=True, zerolinecolor='black', zerolinewidth=1)
                        )
                        
                        fig.add_annotation(
                            text="Acima de 0: Aumenta audi√™ncia da Globo | Abaixo de 0: Reduz audi√™ncia da Globo",
                            xref="paper", yref="paper",
                            x=0.5, y=1.05,
                            showarrow=False,
                            font=dict(size=10)
                        )
                        
                        st.plotly_chart(fig, use_container_width=True)
                        
                        # Create timeline visualization
                        st.markdown("### Evolu√ß√£o Temporal")
                        
                        st.markdown(f"""
                        O gr√°fico abaixo mostra a evolu√ß√£o da audi√™ncia da TV Globo ao longo do tempo, 
                        com marcadores destacando quando o programa {selected_program} foi exibido em cada emissora.
                        Isso permite visualizar o impacto em tempo real do programa na audi√™ncia da Globo.
                        """)
                        
                        # Create figure for temporal analysis
                        fig_time = go.Figure()
                        
                        # Add base audience line
                        fig_time.add_trace(
                            go.Scatter(
                                x=selected_df["data_hora"],
                                y=selected_df[tv_col],
                                mode="lines",
                                name="Audi√™ncia TV Globo",
                                line=dict(color="lightgray", width=1)
                            )
                        )
                        
                        # Colors for different broadcasters
                        broadcaster_colors = {
                            "GLOBO": "green",
                            "SBT": "blue",
                            "RECORD": "red",
                            "BAND": "purple",
                            "TV BAND": "purple"
                        }
                        
                        # Add markers for program occurrences by broadcaster
                        for col in program_cols:
                            parts = col.split('_')
                            broadcaster = parts[3] if len(parts) >= 6 else "Unknown"
                            
                            # Filter data for when this program is on
                            program_data = selected_df[selected_df[col] > 0]
                            
                            if not program_data.empty:
                                color = broadcaster_colors.get(broadcaster, "gray")
                                
                                fig_time.add_trace(
                                    go.Scatter(
                                        x=program_data["data_hora"],
                                        y=program_data[tv_col],
                                        mode="markers",
                                        name=f"{selected_program} na {broadcaster}",
                                        marker=dict(
                                            color=color,
                                            size=8,
                                            symbol="circle"
                                        )
                                    )
                                )
                        
                        # Update layout
                        fig_time.update_layout(
                            title=f"Audi√™ncia da TV Globo Durante Exibi√ß√£o de {selected_program} por Emissora",
                            xaxis_title="Data/Hora",
                            yaxis_title="Audi√™ncia TV Globo (cov%)",
                            legend_title="Eventos",
                            hovermode="closest"
                        )
                        
                        st.plotly_chart(fig_time, use_container_width=True)
                        
                        # Display a table with the impact data
                        st.markdown("### Impacto Detalhado por Emissora")
                        
                        impact_table = impact_df[["Emissora", "Impacto Formatado", "Dire√ß√£o", "Ocorr√™ncias"]]
                        impact_table = impact_table.rename(columns={"Impacto Formatado": "Impacto na Audi√™ncia da Globo"})
                        
                        st.dataframe(impact_table, hide_index=True, use_container_width=True)
                    else:
                        st.warning(f"N√£o h√° dados suficientes para analisar o impacto do programa {selected_program}.")
                else:
                    st.warning(f"N√£o foram encontradas informa√ß√µes para o programa {selected_program}.")
            else:
                st.warning("N√£o foi poss√≠vel identificar tipos de programas recorrentes.")
                
            # Show overall ranking of program impacts
            st.markdown("### Ranking de Impacto de Programas na Audi√™ncia da TV Globo")
            
            all_program_impacts = []
            
            for col in recorrente_cols:
                parts = col.split('_')
                if len(parts) >= 6:
                    program = parts[4]
                    broadcaster = parts[3]
                    
                    valid_data = selected_df.dropna(subset=[col, tv_col])
                    if valid_data.empty or valid_data[col].sum() == 0:
                        continue
                    
                    program_on = valid_data[valid_data[col] > 0][tv_col].mean()
                    program_off = valid_data[valid_data[col] == 0][tv_col].mean()
                    
                    if program_off > 0:
                        impact_pct = ((program_on / program_off) - 1) * 100
                        relation_type = "pr√≥pria" if broadcaster == "GLOBO" else "concorrente"
                        
                        all_program_impacts.append({
                            "Programa": program,
                            "Emissora": broadcaster,
                            "Tipo": relation_type,
                            "Impacto (%)": impact_pct,
                            "Impacto Abs (%)": abs(impact_pct),
                            "Dire√ß√£o": "Positivo" if impact_pct > 0 else "Negativo"
                        })
            
            if all_program_impacts:
                # Convert to DataFrame
                all_impacts_df = pd.DataFrame(all_program_impacts)
                
                # Create two tables: top positive and top negative impacts
                if not all_impacts_df[all_impacts_df["Impacto (%)"] > 0].empty:
                    st.markdown("#### Programas com Maior Impacto Positivo na Audi√™ncia da Globo")
                    positive_df = all_impacts_df[all_impacts_df["Impacto (%)"] > 0].sort_values("Impacto (%)", ascending=False).head(5)
                    positive_df["Impacto (%)"] = positive_df["Impacto (%)"].apply(lambda x: f"{x:.2f}%")
                    
                    st.dataframe(
                        positive_df[["Programa", "Emissora", "Tipo", "Impacto (%)"]],
                        hide_index=True,
                        use_container_width=True
                    )
                
                if not all_impacts_df[all_impacts_df["Impacto (%)"] < 0].empty:
                    st.markdown("#### Programas com Maior Impacto Negativo na Audi√™ncia da Globo")
                    negative_df = all_impacts_df[all_impacts_df["Impacto (%)"] < 0].sort_values("Impacto (%)", ascending=True).head(5)
                    negative_df["Impacto (%)"] = negative_df["Impacto (%)"].apply(lambda x: f"{x:.2f}%")
                    
                    st.dataframe(
                        negative_df[["Programa", "Emissora", "Tipo", "Impacto (%)"]],
                        hide_index=True,
                        use_container_width=True
                    )
                    
                    # Create insight about competitors stealing audience
                    competitors_negative = negative_df[negative_df["Emissora"] != "GLOBO"]
                    if not competitors_negative.empty:
                        top_competitor = competitors_negative.iloc[0]
                        
                        st.error(f"""
                        **Maior 'Ladr√£o' de Audi√™ncia:** O programa {top_competitor['Programa']} na {top_competitor['Emissora']} 
                        causa a maior redu√ß√£o na audi√™ncia da TV Globo ({top_competitor['Impacto (%)']}).
                        
                        Isso indica uma forte competi√ß√£o direta por audi√™ncia, onde os telespectadores est√£o 
                        escolhendo este programa em vez da programa√ß√£o da Globo no mesmo hor√°rio.
                        """)
        else:
            st.warning("N√£o foram encontrados dados sobre programas recorrentes.")

    ########################################
    # 5. Genre Analysis Tab                #
    ########################################
    with tabs[2]:
        st.subheader("An√°lise de G√™neros de Programa√ß√£o")
        
        st.markdown("""
        Diferentes g√™neros de programa√ß√£o t√™m impactos distintos na audi√™ncia da TV Globo.
        Esta an√°lise mostra como cada g√™nero, tanto na pr√≥pria Globo quanto em emissoras concorrentes,
        afeta os n√≠veis de audi√™ncia da Globo, permitindo identificar:
        
        1. Quais g√™neros da pr√≥pria Globo atraem mais audi√™ncia
        2. Quais g√™neros em emissoras concorrentes mais "roubam" audi√™ncia da Globo
        """)
        
        # Find columns for program genres
        genero_cols = [col for col in selected_df.columns if col.startswith('EXTERNO_GRADE_GENERO_')]
        
        if genero_cols and tv_col:
            # Extract unique genres and broadcasters
            genres = set()
            broadcasters = set()
            
            for col in genero_cols:
                parts = col.split('_')
                if len(parts) >= 6:  # Ensure we have enough parts
                    broadcaster = parts[3]  # Extract broadcaster
                    genre = parts[4]  # Extract genre
                    
                    genres.add(genre)
                    broadcasters.add(broadcaster)
            
            genres = sorted(list(genres))
            broadcasters = sorted(list(broadcasters))
            
            if genres:
                # Let user select a genre to analyze
                selected_genre = st.selectbox(
                    "Selecione um g√™nero para an√°lise:",
                    options=genres
                )
                
                # Get all columns related to the selected genre
                genre_cols = [col for col in genero_cols if f"_GENERO_{selected_genre}_" in col or f"_GENERO_{selected_genre}" in col]
                
                if genre_cols:
                    st.markdown(f"### Impacto do G√™nero {selected_genre} na Audi√™ncia da TV Globo")
                    
                    # Calculate impact for each broadcaster
                    impact_data = []
                    
                    for col in genre_cols:
                        # Extract broadcaster name
                        parts = col.split('_')
                        if len(parts) >= 4:
                            broadcaster = parts[3]
                            
                            # Calculate audience with and without genre
                            valid_data = selected_df.dropna(subset=[col, tv_col])
                            if valid_data.empty or valid_data[col].sum() == 0:
                                continue
                                
                            genre_on = valid_data[valid_data[col] > 0][tv_col].mean()
                            genre_off = valid_data[valid_data[col] == 0][tv_col].mean()
                            
                            # Calculate impact percentage
                            if genre_off > 0:  # Avoid division by zero
                                impact_pct = ((genre_on / genre_off) - 1) * 100
                                
                                # Count occurrences
                                occurrences = valid_data[valid_data[col] > 0].shape[0]
                                
                                relation_type = "pr√≥pria" if broadcaster == "GLOBO" else "concorrente"
                                
                                impact_data.append({
                                    "G√™nero": selected_genre,
                                    "Emissora": broadcaster,
                                    "Tipo": relation_type,
                                    "Impacto (%)": impact_pct,
                                    "Dire√ß√£o": "Positivo" if impact_pct > 0 else "Negativo",
                                    "Ocorr√™ncias": occurrences
                                })
                    
                    if impact_data:
                        # Convert to DataFrame and format
                        impact_df = pd.DataFrame(impact_data)
                        impact_df["Impacto Formatado"] = impact_df["Impacto (%)"].apply(lambda x: f"{x:.2f}%")
                        
                        # Create a key insight about this genre's impact
                        if "GLOBO" in impact_df["Emissora"].values:
                            globo_impact = impact_df[impact_df["Emissora"] == "GLOBO"]["Impacto (%)"].values[0]
                            direction = "aumenta" if globo_impact > 0 else "reduz"
                            
                            st.info(f"**{selected_genre} na Globo:** Quando este g√™nero √© exibido na pr√≥pria Globo, {direction} "
                                  f"a audi√™ncia da emissora em {abs(globo_impact):.2f}% em m√©dia.")
                        
                        # Find competitors with biggest impact
                        competitors = impact_df[impact_df["Emissora"] != "GLOBO"]
                        if not competitors.empty:
                            strongest_competitor = competitors.loc[competitors["Impacto (%)"].abs().idxmax()]
                            comp_direction = "aumenta" if strongest_competitor["Impacto (%)"] > 0 else "reduz"
                            
                            st.warning(f"**{selected_genre} na {strongest_competitor['Emissora']}:** Quando este g√™nero √© exibido nesta emissora concorrente, "
                                     f"{comp_direction} a audi√™ncia da Globo em {abs(strongest_competitor['Impacto (%)']):.2f}% em m√©dia.")
                            
                            if strongest_competitor["Impacto (%)"] < 0:
                                st.error(f"üëâ Isso sugere que programas do g√™nero {selected_genre} na {strongest_competitor['Emissora']} est√£o "
                                       f"'roubando' audi√™ncia da TV Globo, potencialmente atraindo seus telespectadores.")
                        
                        # Add a special color for Globo vs competitors
                        color_map = {"pr√≥pria": "green", "concorrente": "red"}
                        
                        # Create a bar chart comparing impact across broadcasters
                        fig = px.bar(
                            impact_df,
                            x="Emissora",
                            y="Impacto (%)",
                            color="Tipo",
                            text="Impacto Formatado",
                            title=f"Impacto do G√™nero {selected_genre} na Audi√™ncia da TV Globo por Emissora",
                            color_discrete_map=color_map,
                            hover_data=["Ocorr√™ncias"]
                        )
                        
                        fig.update_layout(
                            xaxis_title="Emissora",
                            yaxis_title="Impacto na Audi√™ncia da Globo (%)",
                            yaxis=dict(zeroline=True, zerolinecolor='black', zerolinewidth=1)
                        )
                        
                        fig.add_annotation(
                            text="Acima de 0: Aumenta audi√™ncia da Globo | Abaixo de 0: Reduz audi√™ncia da Globo",
                            xref="paper", yref="paper",
                            x=0.5, y=1.05,
                            showarrow=False,
                            font=dict(size=10)
                        )
                        
                        st.plotly_chart(fig, use_container_width=True)
                        
                        # Display a table with the impact data
                        st.markdown("### Impacto Detalhado por Emissora")
                        
                        impact_table = impact_df[["Emissora", "Impacto Formatado", "Dire√ß√£o", "Ocorr√™ncias"]]
                        impact_table = impact_table.rename(columns={"Impacto Formatado": "Impacto na Audi√™ncia da Globo"})
                        
                        st.dataframe(impact_table, hide_index=True, use_container_width=True)
                    else:
                        st.warning(f"N√£o h√° dados suficientes para analisar o impacto do g√™nero {selected_genre}.")
                else:
                    st.warning(f"N√£o foram encontradas informa√ß√µes para o g√™nero {selected_genre}.")
                    
                # Show overall ranking of genre impacts
                st.markdown("### Ranking de Impacto de G√™neros na Audi√™ncia da TV Globo")
                
                all_genre_impacts = []
                
                for col in genero_cols:
                    parts = col.split('_')
                    if len(parts) >= 5:
                        broadcaster = parts[3]
                        genre = parts[4]
                        
                        valid_data = selected_df.dropna(subset=[col, tv_col])
                        if valid_data.empty or valid_data[col].sum() == 0:
                            continue
                        
                        genre_on = valid_data[valid_data[col] > 0][tv_col].mean()
                        genre_off = valid_data[valid_data[col] == 0][tv_col].mean()
                        
                        if genre_off > 0:
                            impact_pct = ((genre_on / genre_off) - 1) * 100
                            relation_type = "pr√≥pria" if broadcaster == "GLOBO" else "concorrente"
                            
                            all_genre_impacts.append({
                                "G√™nero": genre,
                                "Emissora": broadcaster,
                                "Tipo": relation_type,
                                "Impacto (%)": impact_pct,
                                "Impacto Abs (%)": abs(impact_pct),
                                "Dire√ß√£o": "Positivo" if impact_pct > 0 else "Negativo"
                            })
                
                if all_genre_impacts:
                    # Convert to DataFrame
                    all_impacts_df = pd.DataFrame(all_genre_impacts)
                    
                    # Create two tabs for viewing by genre or by broadcaster
                    genre_view_tabs = st.tabs(["Ver por G√™nero", "Ver por Emissora"])
                    
                    with genre_view_tabs[0]:
                        # Calculate average impact by genre across broadcasters
                        genre_avg = all_impacts_df.groupby("G√™nero")["Impacto (%)"].mean().reset_index()
                        genre_avg = genre_avg.sort_values("Impacto (%)", ascending=False)
                        
                        # Top and bottom 5 genres
                        top_genres = genre_avg.head(5)
                        bottom_genres = genre_avg.tail(5)
                        
                        col1, col2 = st.columns(2)
                        
                        with col1:
                            st.markdown("#### Top 5 G√™neros que Mais Aumentam Audi√™ncia da Globo")
                            fig_top = px.bar(
                                top_genres,
                                x="G√™nero",
                                y="Impacto (%)",
                                text=top_genres["Impacto (%)"].apply(lambda x: f"{x:.2f}%"),
                                color="Impacto (%)",
                                color_continuous_scale=["yellow", "green"]
                            )
                            
                            fig_top.update_layout(
                                xaxis_title="G√™nero",
                                yaxis_title="Impacto M√©dio (%)",
                                xaxis_tickangle=-45
                            )
                            
                            st.plotly_chart(fig_top, use_container_width=True)
                        
                        with col2:
                            st.markdown("#### Top 5 G√™neros que Mais Reduzem Audi√™ncia da Globo")
                            fig_bottom = px.bar(
                                bottom_genres,
                                x="G√™nero",
                                y="Impacto (%)",
                                text=bottom_genres["Impacto (%)"].apply(lambda x: f"{x:.2f}%"),
                                color="Impacto (%)",
                                color_continuous_scale=["red", "yellow"]
                            )
                            
                            fig_bottom.update_layout(
                                xaxis_title="G√™nero",
                                yaxis_title="Impacto M√©dio (%)",
                                xaxis_tickangle=-45
                            )
                            
                            st.plotly_chart(fig_bottom, use_container_width=True)
                    
                    with genre_view_tabs[1]:
                        # Group by broadcaster and display top genres for each
                        for broadcaster in broadcasters:
                            broadcaster_data = all_impacts_df[all_impacts_df["Emissora"] == broadcaster]
                            
                            if not broadcaster_data.empty:
                                st.markdown(f"#### Top G√™neros na {broadcaster}")
                                
                                # Sort by impact
                                broadcaster_data = broadcaster_data.sort_values("Impacto (%)", ascending=False)
                                broadcaster_data["Impacto (%)"] = broadcaster_data["Impacto (%)"].apply(lambda x: f"{x:.2f}%")
                                
                                # Show the table
                                st.dataframe(
                                    broadcaster_data[["G√™nero", "Impacto (%)", "Dire√ß√£o"]],
                                    hide_index=True,
                                    use_container_width=True
                                )
                                
                                # Add an insight about competition
                                if broadcaster != "GLOBO":
                                    negative_impacts = all_impacts_df[(all_impacts_df["Emissora"] == broadcaster) & 
                                                                    (all_impacts_df["Impacto (%)"] < 0)]
                                    
                                    if not negative_impacts.empty:
                                        worst_genre = negative_impacts.sort_values("Impacto (%)").iloc[0]
                                        
                                        st.warning(f"""
                                        **Competi√ß√£o Direta:** O g√™nero {worst_genre['G√™nero']} na {broadcaster} 
                                        causa uma redu√ß√£o de {abs(worst_genre['Impacto (%)']):.2f}% na audi√™ncia da Globo,
                                        o que sugere forte competi√ß√£o neste segmento de programa√ß√£o.
                                        """)
                else:
                    st.warning("N√£o h√° dados suficientes para criar um ranking de g√™neros.")
            else:
                st.warning("N√£o foi poss√≠vel identificar g√™neros de programa√ß√£o.")
        else:
            st.warning("N√£o foram encontrados dados sobre g√™neros de programa√ß√£o.")

    ########################################
    # 6. Isolated Events Analysis Tab      #
    ########################################
    with tabs[3]:
        st.subheader("An√°lise de Eventos Isolados")
        
        st.markdown("""
        Eventos isolados representam acontecimentos pontuais como not√≠cias importantes, eventos especiais, 
        ou lan√ßamentos que podem ter um impacto significativo na audi√™ncia da TV Globo.
        
        Diferentemente dos programas recorrentes, estes eventos s√£o √∫nicos ou raros, tornando sua an√°lise 
        particularmente valiosa para entender o impacto de acontecimentos espec√≠ficos.
        """)
        
        # Find columns for isolated events
        isolado_cols = [col for col in selected_df.columns if col.startswith('EXTERNO_ISOLADO_')]
        
        if isolado_cols and tv_col:
            # Create a timeline showing isolated events
            st.markdown("### Linha do Tempo de Eventos Isolados")
            
            st.markdown("""
            O gr√°fico abaixo mostra a audi√™ncia da TV Globo ao longo do tempo, com marcadores nos momentos 
            em que ocorreram eventos isolados espec√≠ficos. Isso permite visualizar o impacto imediato destes 
            eventos na audi√™ncia.
            """)
            
            # Create timeline figure
            fig_timeline = go.Figure()
            
            # Add base audience line
            fig_timeline.add_trace(
                go.Scatter(
                    x=selected_df["data_hora"],
                    y=selected_df[tv_col],
                    mode="lines",
                    name="Audi√™ncia TV Globo",
                    line=dict(color="lightgray", width=1)
                )
            )
            
            # Generate colors for different events
            event_colors = px.colors.qualitative.Plotly
            
            # Add markers for each isolated event
            for i, col in enumerate(isolado_cols):
                event_name = col.replace('EXTERNO_ISOLADO_', '').replace('_', ' ')
                color = event_colors[i % len(event_colors)]
                
                # Get data points where the event occurred
                event_data = selected_df[selected_df[col] > 0]
                
                if not event_data.empty:
                    fig_timeline.add_trace(
                        go.Scatter(
                            x=event_data["data_hora"],
                            y=event_data[tv_col],
                            mode="markers",
                            name=event_name,
                            marker=dict(
                                color=color,
                                size=10,
                                symbol="star"
                            )
                        )
                    )
            
            # Update layout
            fig_timeline.update_layout(
                title="Audi√™ncia da TV Globo Durante Eventos Isolados",
                xaxis_title="Data/Hora",
                yaxis_title="Audi√™ncia TV Globo (cov%)",
                legend_title="Eventos",
                hovermode="closest"
            )
            
            st.plotly_chart(fig_timeline, use_container_width=True)
            
            # Calculate impact of each isolated event
            st.markdown("### Impacto dos Eventos Isolados na Audi√™ncia")
            
            st.markdown("""
            A tabela abaixo quantifica o impacto de cada evento isolado na audi√™ncia da TV Globo.
            Para uma compara√ß√£o justa, comparamos a audi√™ncia durante o evento com a audi√™ncia m√©dia
            em per√≠odos similares (mesmo dia da semana e hor√°rio) sem eventos.
            """)
            
            # Calculate baseline for fair comparison
            event_impacts = []
            
            for col in isolado_cols:
                event_name = col.replace('EXTERNO_ISOLADO_', '').replace('_', ' ')
                
                # Get data points where the event occurred
                event_data = selected_df[selected_df[col] > 0]
                
                if not event_data.empty:
                    # Extract day of week and hour information for comparison
                    event_data["day_of_week"] = event_data["data_hora"].dt.dayofweek
                    event_data["hour"] = event_data["data_hora"].dt.hour
                    
                    # Calculate average audience during the event
                    event_audience = event_data[tv_col].mean()
                    
                    # Create baseline for comparison - same days of week and hours without the event
                    similar_periods = []
                    
                    for _, row in event_data.iterrows():
                        day = row["day_of_week"]
                        hour = row["hour"]
                        
                        # Find similar periods (same day & hour) without the event
                        similar = selected_df[
                            (selected_df["data_hora"].dt.dayofweek == day) & 
                            (selected_df["data_hora"].dt.hour == hour) & 
                            (selected_df[col] == 0)
                        ]
                        
                        similar_periods.append(similar)
                    
                    # Combine all similar periods
                    if similar_periods:
                        baseline_data = pd.concat(similar_periods, ignore_index=True)
                        
                        if not baseline_data.empty:
                            baseline_audience = baseline_data[tv_col].mean()
                            
                            # Calculate impact
                            if baseline_audience > 0:
                                impact_pct = ((event_audience / baseline_audience) - 1) * 100
                                
                                event_impacts.append({
                                    "Evento": event_name,
                                    "Audi√™ncia Durante Evento": event_audience,
                                    "Audi√™ncia T√≠pica (Baseline)": baseline_audience,
                                    "Impacto (%)": impact_pct,
                                    "Dire√ß√£o": "Positivo" if impact_pct > 0 else "Negativo",
                                    "Ocorr√™ncias": len(event_data)
                                })
            
            if event_impacts:
                # Convert to DataFrame and sort by impact
                impact_df = pd.DataFrame(event_impacts)
                impact_df = impact_df.sort_values("Impacto (%)", ascending=False)
                
                # Format columns for display
                impact_df["Audi√™ncia Durante Evento"] = impact_df["Audi√™ncia Durante Evento"].apply(lambda x: f"{x:.2f}%")
                impact_df["Audi√™ncia T√≠pica (Baseline)"] = impact_df["Audi√™ncia T√≠pica (Baseline)"].apply(lambda x: f"{x:.2f}%")
                impact_df["Impacto (%)"] = impact_df["Impacto (%)"].apply(lambda x: f"{x:.2f}%")
                
                # Display as table
                st.dataframe(impact_df, hide_index=True, use_container_width=True)
                
                # Create a bar chart of impacts
                impact_df_plot = pd.DataFrame(event_impacts)  # Create a new copy for plotting
                
                fig_impact = px.bar(
                    impact_df_plot,
                    x="Evento",
                    y="Impacto (%)",
                    color="Dire√ß√£o",
                    text=impact_df_plot["Impacto (%)"].apply(lambda x: f"{x:.2f}%"),
                    title="Impacto de Eventos Isolados na Audi√™ncia da TV Globo",
                    color_discrete_map={"Positivo": "green", "Negativo": "red"},
                    hover_data=["Ocorr√™ncias"]
                )
                
                fig_impact.update_layout(
                    xaxis_title="Evento",
                    yaxis_title="Impacto na Audi√™ncia (%)",
                    xaxis_tickangle=-45,
                    yaxis=dict(zeroline=True, zerolinecolor='black', zerolinewidth=1)
                )
                
                st.plotly_chart(fig_impact, use_container_width=True)
                
                # Generate insights
                if not impact_df.empty:
                    top_positive = impact_df[impact_df["Dire√ß√£o"] == "Positivo"]
                    top_negative = impact_df[impact_df["Dire√ß√£o"] == "Negativo"]
                    
                    if not top_positive.empty:
                        top_pos = top_positive.iloc[0]
                        
                        st.success(f"""
                        **Evento com Maior Impacto Positivo:** {top_pos['Evento']} aumentou a audi√™ncia da Globo em 
                        {top_pos['Impacto (%)']} comparado com per√≠odos similares sem o evento.
                        
                        Este tipo de evento representa uma oportunidade para aumentar a audi√™ncia em momentos estrat√©gicos.
                        """)
                    
                    if not top_negative.empty:
                        top_neg = top_negative.iloc[0]
                        
                        st.error(f"""
                        **Evento com Maior Impacto Negativo:** {top_neg['Evento']} reduziu a audi√™ncia da Globo em 
                        {top_neg['Impacto (%)']} comparado com per√≠odos similares.
                        
                        Eventos deste tipo podem estar desviando a aten√ß√£o dos telespectadores para outras atividades
                        ou canais concorrentes.
                        """)
            else:
                st.warning("N√£o foi poss√≠vel calcular o impacto dos eventos isolados devido a dados insuficientes.")
        else:
            st.warning("N√£o foram encontrados dados sobre eventos isolados.")

    ######################################
    # 7. Social Volume Analysis Tab      #
    ######################################
    with tabs[4]:
        st.subheader("An√°lise de Volume Social")
        
        st.markdown("""
        O volume de conversas nas redes sociais pode ser tanto um indicador como um impulsionador da audi√™ncia de TV.
        Programas que geram mais conversa√ß√£o podem atrair novos espectadores, enquanto assuntos muito discutidos
        nas redes sociais podem desviar a aten√ß√£o da TV.
        
        Esta an√°lise examina a rela√ß√£o entre o volume de atividade social e m√©tricas de audi√™ncia da TV Globo.
        """)
        
        # Find social volume columns based on new naming pattern
        social_cols = [col for col in selected_df.columns if col.startswith('EXTERNO_NPS_')]
        
        if social_cols and tv_col:
            # Filter data where both social and tv_col have valid values
            valid_social_data = selected_df.dropna(subset=social_cols + [tv_col])
            
            # Filter for non-zero social values
            for col in social_cols:
                valid_social_data = valid_social_data[valid_social_data[col] > 0]
            
            if not valid_social_data.empty:
                # Create time series chart comparing social volume with TV audience
                fig = make_subplots(specs=[[{"secondary_y": True}]])
                
                # Add TV audience line
                fig.add_trace(
                    go.Scatter(
                        x=valid_social_data['data_hora'],
                        y=valid_social_data[tv_col],
                        name='Audi√™ncia TV Globo (cov%)',
                        line=dict(color='rgb(31, 119, 180)', width=3)
                    ),
                    secondary_y=False
                )
                
                # Add social volume lines with different colors
                colors = ['rgb(255, 127, 14)', 'rgb(44, 160, 44)', 'rgb(214, 39, 40)', 
                        'rgb(148, 103, 189)', 'rgb(140, 86, 75)']
                
                for i, col in enumerate(social_cols):
                    display_name = col.replace('EXTERNO_NPS_', '').replace('_', ' ').title()
                    
                    fig.add_trace(
                        go.Scatter(
                            x=valid_social_data['data_hora'],
                            y=valid_social_data[col],
                            name=display_name,
                            line=dict(color=colors[i % len(colors)], width=2)
                        ),
                        secondary_y=True
                    )
                
                # Update layout
                time_unit = "" if granularity == "Hor√°rio" else "Di√°ria" if granularity == "Di√°rio" else "Semanal"
                fig.update_layout(
                    title=f'Evolu√ß√£o {time_unit} da Audi√™ncia TV Globo vs. Volume Social ({granularity})',
                    xaxis_title='Data e Hora' if granularity == "Hor√°rio" else 'Data',
                    yaxis_title='Audi√™ncia TV Globo (cov%)',
                    yaxis2_title='Volume Social',
                    legend_title='M√©tricas',
                    hovermode="x unified"
                )
                
                st.plotly_chart(fig, use_container_width=True)
                
                # Create correlation analysis
                st.markdown("### Correla√ß√£o entre Volume Social e Audi√™ncia TV")
                
                # Calculate correlation matrix
                correlation_data = []
                
                for col in social_cols:
                    display_name = col.replace('EXTERNO_NPS_', '').replace('_', ' ').title()
                    corr = valid_social_data[col].corr(valid_social_data[tv_col])
                    
                    correlation_data.append({
                        'M√©trica Social': display_name,
                        'Correla√ß√£o': corr,
                        'For√ßa': abs(corr)
                    })
                
                if correlation_data:
                    corr_df = pd.DataFrame(correlation_data)
                    corr_df = corr_df.sort_values('For√ßa', ascending=False)
                    
                    # Create bar chart of correlations
                    fig_corr = px.bar(
                        corr_df,
                        x='M√©trica Social',
                        y='Correla√ß√£o',
                        color='Correla√ß√£o',
                        text=corr_df['Correla√ß√£o'].apply(lambda x: f"{x:.2f}"),
                        title='Correla√ß√£o entre M√©tricas Sociais e Audi√™ncia TV Globo',
                        color_continuous_scale=['red', 'white', 'green']
                    )
                    
                    st.plotly_chart(fig_corr, use_container_width=True)
                    
                    # Show scatter plot for the most correlated metric
                    if not corr_df.empty:
                        strongest_metric = corr_df.iloc[0]['M√©trica Social']
                        strongest_col = [col for col in social_cols if strongest_metric.lower().replace(' ', '_') in col.lower()][0]
                        
                        st.markdown(f"### Rela√ß√£o Detalhada: {strongest_metric} vs. Audi√™ncia")
                        
                        fig_scatter = px.scatter(
                            valid_social_data,
                            x=strongest_col,
                            y=tv_col,
                            trendline="ols",
                            labels={
                                strongest_col: strongest_metric,
                                tv_col: 'Audi√™ncia TV Globo (cov%)'
                            },
                            title=f'Rela√ß√£o entre {strongest_metric} e Audi√™ncia TV Globo'
                        )
                        
                        st.plotly_chart(fig_scatter, use_container_width=True)
                        
                        # Add insight about relationship
                        strongest_corr = corr_df.iloc[0]['Correla√ß√£o']
                        
                        if abs(strongest_corr) > 0.3:
                            if strongest_corr > 0:
                                st.success(f"""
                                **Correla√ß√£o Positiva Significativa:** O aumento no {strongest_metric} est√° associado a um 
                                aumento na audi√™ncia da TV Globo (correla√ß√£o: {strongest_corr:.2f}).
                                
                                Isso sugere que este tipo de atividade social pode estar impulsionando telespectadores 
                                para assistir √† programa√ß√£o da Globo, possivelmente indicando engajamento em "segunda tela".
                                """)
                            else:
                                st.error(f"""
                                **Correla√ß√£o Negativa Significativa:** O aumento no {strongest_metric} est√° associado a uma 
                                redu√ß√£o na audi√™ncia da TV Globo (correla√ß√£o: {strongest_corr:.2f}).
                                
                                Isso sugere que este tipo de atividade social pode estar competindo pela aten√ß√£o dos 
                                telespectadores, potencialmente desviando-os da programa√ß√£o da Globo.
                                """)
                
                # Create lag analysis if not hourly
                if granularity != "Hor√°rio" and len(social_cols) > 0:
                    primary_social_col = social_cols[0]
                    display_name = primary_social_col.replace('EXTERNO_NPS_', '').replace('_', ' ').title()
                    
                    st.markdown("### An√°lise de Lag: Volume Social vs. Audi√™ncia")
                    
                    st.markdown("""
                    Esta an√°lise verifica se um aumento no volume social precede ou sucede 
                    um aumento na audi√™ncia TV. Um lag positivo significativo sugere que a conversa√ß√£o
                    social pode funcionar como um preditor da audi√™ncia futura.
                    """)
                    
                    # Create lag columns
                    lags = [1, 2, 3, 7]  # Look at 1, 2, 3, and 7 days/weeks lag
                    lag_corrs = []
                    
                    for lag in lags:
                        lag_col = f'social_lag_{lag}'
                        valid_social_data[lag_col] = valid_social_data[primary_social_col].shift(lag)
                        
                        # Calculate correlation with audience, excluding NaN values
                        lag_data = valid_social_data.dropna(subset=[lag_col, tv_col])
                        
                        if not lag_data.empty:
                            corr = lag_data[lag_col].corr(lag_data[tv_col])
                            if not pd.isna(corr):  # Only include valid correlations
                                unit = "dias" if granularity == "Di√°rio" else "semanas"
                                lag_corrs.append({
                                    f'Lag ({unit})': lag,
                                    'Correla√ß√£o': corr
                                })
                    
                    if lag_corrs:
                        # Convert to DataFrame
                        lag_df = pd.DataFrame(lag_corrs)
                        
                        # Create bar chart
                        unit = "dias" if granularity == "Di√°rio" else "semanas"
                        fig_lag = px.bar(
                            lag_df,
                            x=f'Lag ({unit})',
                            y='Correla√ß√£o',
                            title=f'Correla√ß√£o entre Volume Social (com lag) e Audi√™ncia TV Globo',
                            labels={
                                f'Lag ({unit})': f'Volume Social Defasado ({unit})',
                                'Correla√ß√£o': 'Correla√ß√£o com Audi√™ncia TV Globo'
                            },
                            color='Correla√ß√£o',
                            color_continuous_scale=['red', 'yellow', 'green']
                        )
                        
                        st.plotly_chart(fig_lag, use_container_width=True)
                        
                        # Generate insights based on lag analysis
                        max_lag_corr = max(lag_df['Correla√ß√£o'])
                        max_lag = lag_df.loc[lag_df['Correla√ß√£o'].idxmax(), f'Lag ({unit})']
                        
                        if abs(max_lag_corr) > 0.3:
                            direction = "positiva" if max_lag_corr > 0 else "negativa"
                            effect = "preditor" if max_lag_corr > 0 else "indicador de poss√≠vel queda"
                            
                            st.success(f"**Efeito Temporal:** A correla√ß√£o {direction} mais forte ({max_lag_corr:.2f}) "
                                    f"ocorre com {max_lag} {unit} de defasagem, sugerindo que o volume social "
                                    f"pode ser um {effect} da audi√™ncia TV Globo futura.")
                else:
                    # For hourly analysis, provide insight about real-time social engagement
                    st.markdown("### An√°lise de Engajamento Social em Tempo Real")
                    
                    st.markdown("""
                    Para dados por hora, a an√°lise de correla√ß√£o em tempo real √© mais relevante que a an√°lise de lag.
                    A correla√ß√£o atual mostra se as pessoas est√£o engajadas nas redes sociais durante o mesmo per√≠odo
                    em que est√£o assistindo TV, o que pode indicar o uso de "segunda tela" ou conversa√ß√£o social
                    sobre os programas em andamento.
                    """)
                    
                    # Analyze correlation during prime time vs other times for hourly data
                    if granularity == "Hor√°rio" and len(social_cols) > 0:
                        primary_social_col = social_cols[0]
                        
                        prime_time_hours = list(range(19, 23))  # 7pm to 10pm
                        
                        prime_df = valid_social_data[valid_social_data['data_hora'].dt.hour.isin(prime_time_hours)]
                        non_prime_df = valid_social_data[~valid_social_data['data_hora'].dt.hour.isin(prime_time_hours)]
                        
                        if not prime_df.empty and not non_prime_df.empty:
                            prime_corr = prime_df[primary_social_col].corr(prime_df[tv_col])
                            non_prime_corr = non_prime_df[primary_social_col].corr(non_prime_df[tv_col])
                            
                            if not pd.isna(prime_corr) and not pd.isna(non_prime_corr):
                                stronger = "hor√°rio nobre" if abs(prime_corr) > abs(non_prime_corr) else "fora do hor√°rio nobre"
                                
                                st.success(f"**Diferen√ßa por Hor√°rio:** A correla√ß√£o entre volume social e audi√™ncia da Globo √© mais forte durante o {stronger} "
                                        f"({prime_corr:.2f} vs {non_prime_corr:.2f}), sugerindo que "
                                        f"{'o comportamento de segunda tela √© mais prevalente no hor√°rio nobre' if stronger == 'hor√°rio nobre' else 'o uso de redes sociais durante o dia tem impacto maior na audi√™ncia fora do hor√°rio nobre'}.")
            else:
                st.warning("Dados insuficientes para an√°lise de volume social no per√≠odo selecionado.")
        else:
            st.warning("Dados sobre volume social n√£o est√£o dispon√≠veis.")

    ######################################
    # 8. Summary Analysis Tab            #
    ######################################
    with tabs[5]:
        st.subheader("Resumo dos Insights")
        
        st.markdown("""
        Esta se√ß√£o consolida os principais insights de todas as categorias analisadas,
        destacando os fatores externos que mais impactam a audi√™ncia da TV Globo.
        """)
        
        if tv_col:
            # Collect all relevant columns for correlation analysis
            relevant_cols = []
            relevant_cols.extend([col for col in selected_df.columns if col.startswith('EXTERNO_ECONOMICO_')])
            relevant_cols.extend([col for col in selected_df.columns if col.startswith('EXTERNO_GRADE_')])
            relevant_cols.extend([col for col in selected_df.columns if col.startswith('EXTERNO_ISOLADO_')])
            relevant_cols.extend([col for col in selected_df.columns if col.startswith('EXTERNO_NPS_')])
            
            if relevant_cols:
                # Calculate correlation with audience metric
                correlations = {}
                
                for col in relevant_cols:
                    valid_data = selected_df.dropna(subset=[col, tv_col])
                    if not valid_data.empty and valid_data[col].std() > 0:  # Ensure there's variation
                        corr = valid_data[col].corr(valid_data[tv_col])
                        if not pd.isna(corr):
                            correlations[col] = corr
                
                if correlations:
                    # Convert to DataFrame
                    corr_df = pd.DataFrame({
                        'Fator': list(correlations.keys()),
                        'Correla√ß√£o': list(correlations.values()),
                        'For√ßa': [abs(c) for c in correlations.values()]
                    })
                    
                    # Add category
                    def categorize(factor):
                        if factor.startswith('EXTERNO_ECONOMICO_'):
                            return 'Indicador Econ√¥mico'
                        elif factor.startswith('EXTERNO_GRADE_RECORRENTE_'):
                            parts = factor.split('_')
                            if len(parts) >= 5:
                                broadcaster = parts[4]
                                if broadcaster == "GLOBO":
                                    return 'Programa Globo'
                                else:
                                    return 'Programa Concorrente'
                            return 'Programa Recorrente'
                        elif factor.startswith('EXTERNO_GRADE_GENERO_'):
                            parts = factor.split('_')
                            if len(parts) >= 4:
                                broadcaster = parts[3]
                                if broadcaster == "GLOBO":
                                    return 'G√™nero Globo'
                                else:
                                    return 'G√™nero Concorrente'
                            return 'G√™nero de Programa√ß√£o'
                        elif factor.startswith('EXTERNO_ISOLADO_'):
                            return 'Evento Isolado'
                        elif factor.startswith('EXTERNO_NPS_'):
                            return 'Volume Social'
                        else:
                            return 'Outros'
                    
                    corr_df['Categoria'] = corr_df['Fator'].apply(categorize)
                    
                    # Clean up factor names for display
                    def clean_factor_name(factor):
                        if factor.startswith('EXTERNO_ECONOMICO_'):
                            return factor.replace('EXTERNO_ECONOMICO_', '').replace('_', ' ').title()
                        elif factor.startswith('EXTERNO_GRADE_RECORRENTE_'):
                            parts = factor.split('_')
                            if len(parts) >= 6:
                                program = parts[4]
                                broadcaster = parts[3]
                                return f"{program} ({broadcaster})"
                            return factor.replace('EXTERNO_GRADE_RECORRENTE_', '')
                        elif factor.startswith('EXTERNO_GRADE_GENERO_'):
                            parts = factor.split('_')
                            if len(parts) >= 5:
                                broadcaster = parts[3]
                                genre = parts[4]
                                return f"{genre} ({broadcaster})"
                            return factor.replace('EXTERNO_GRADE_GENERO_', '')
                        elif factor.startswith('EXTERNO_ISOLADO_'):
                            return factor.replace('EXTERNO_ISOLADO_', '').replace('_', ' ')
                        elif factor.startswith('EXTERNO_NPS_'):
                            return factor.replace('EXTERNO_NPS_', '').replace('_', ' ').title()
                        else:
                            return factor
                    
                    corr_df['Fator Formatado'] = corr_df['Fator'].apply(clean_factor_name)
                    
                    # Add relationship to Globo
                    def determine_relationship(row):
                        if row['Categoria'] in ['Programa Concorrente', 'G√™nero Concorrente']:
                            if row['Correla√ß√£o'] < 0:
                                return "Rouba audi√™ncia da Globo"
                            else:
                                return "N√£o compete com Globo"
                        elif row['Categoria'] in ['Programa Globo', 'G√™nero Globo']:
                            if row['Correla√ß√£o'] > 0:
                                return "Aumenta audi√™ncia da Globo"
                            else:
                                return "Reduz audi√™ncia da Globo"
                        else:
                            return "Correla√ß√£o Neutra"
                    
                    corr_df['Rela√ß√£o com Globo'] = corr_df.apply(determine_relationship, axis=1)
                    
                    # Sort by absolute correlation strength
                    corr_df = corr_df.sort_values('For√ßa', ascending=False)
                    
                    # Display top factors overall
                    st.markdown("### Fatores Externos com Maior Impacto na Audi√™ncia da Globo")
                    
                    # Take top 10 overall
                    top_overall = corr_df.head(10)
                    
                    # Create a color map based on relationship to Globo
                    relationship_colors = {
                        "Rouba audi√™ncia da Globo": "red",
                        "N√£o compete com Globo": "lightblue",
                        "Aumenta audi√™ncia da Globo": "green",
                        "Reduz audi√™ncia da Globo": "orange",
                        "Correla√ß√£o Neutra": "gray"
                    }
                    
                    fig_top = px.bar(
                        top_overall,
                        x='Fator Formatado',
                        y='Correla√ß√£o',
                        color='Rela√ß√£o com Globo',
                        text=top_overall['Correla√ß√£o'].apply(lambda x: f"{x:.2f}"),
                        title='Top 10 Fatores Externos por Correla√ß√£o com Audi√™ncia da TV Globo',
                        color_discrete_map=relationship_colors
                    )
                    
                    fig_top.update_layout(
                        xaxis_title='Fator Externo',
                        yaxis_title='Correla√ß√£o com Audi√™ncia TV Globo (cov%)',
                        xaxis_tickangle=-45,
                        yaxis=dict(zeroline=True, zerolinecolor='black', zerolinewidth=1)
                    )
                    
                    st.plotly_chart(fig_top, use_container_width=True)
                    
                    # Create special section for competition analysis
                    st.markdown("### An√°lise de Competi√ß√£o: Quem 'Rouba' Audi√™ncia da Globo?")
                    
                    competition_df = corr_df[
                        (corr_df['Categoria'].isin(['Programa Concorrente', 'G√™nero Concorrente'])) & 
                        (corr_df['Correla√ß√£o'] < 0)
                    ].sort_values('Correla√ß√£o', ascending=True)
                    
                    if not competition_df.empty:
                        top_competitors = competition_df.head(5)
                        
                        fig_comp = px.bar(
                            top_competitors,
                            x='Fator Formatado',
                            y='Correla√ß√£o',
                            text=top_competitors['Correla√ß√£o'].apply(lambda x: f"{x:.2f}"),
                            title='Top 5 Programa√ß√µes Concorrentes que Mais "Roubam" Audi√™ncia da Globo',
                            color='Categoria',
                            color_discrete_map={"Programa Concorrente": "red", "G√™nero Concorrente": "darkred"}
                        )
                        
                        fig_comp.update_layout(
                            xaxis_title='Programa√ß√£o Concorrente',
                            yaxis_title='Correla√ß√£o com Audi√™ncia Globo',
                            xaxis_tickangle=-45
                        )
                        
                        st.plotly_chart(fig_comp, use_container_width=True)
                        
                        # Create insight about competition
                        top_competitor = top_competitors.iloc[0]
                        
                        st.error(f"""
                        **Competidor Mais Forte:** {top_competitor['Fator Formatado']} tem a correla√ß√£o negativa mais 
                        forte ({top_competitor['Correla√ß√£o']:.2f}) com a audi√™ncia da Globo.
                        
                        Isso indica que este conte√∫do concorrente est√° efetivamente atraindo telespectadores 
                        que poderiam estar assistindo √† Globo, representando uma amea√ßa competitiva significativa.
                        """)
                    else:
                        st.info("N√£o foram identificados competidores significativos com correla√ß√£o negativa.")
                    
                    # Display top factors by category
                    st.markdown("### An√°lise por Categoria de Fator Externo")
                    
                    # Create columns for the top factor in each category
                    categories = corr_df['Categoria'].unique()
                    cols = st.columns(min(4, len(categories)))
                    
                    for i, category in enumerate(categories):
                        # Get top factor in this category
                        top_in_category = corr_df[corr_df['Categoria'] == category].iloc[0] if not corr_df[corr_df['Categoria'] == category].empty else None
                        
                        if top_in_category is not None:
                            with cols[i % 4]:
                                direction = "positiva" if top_in_category['Correla√ß√£o'] > 0 else "negativa"
                                
                                st.metric(
                                    label=f"Top em {category}",
                                    value=top_in_category['Fator Formatado'],
                                    delta=f"{top_in_category['Correla√ß√£o']:.2f} ({direction})"
                                )
                    
                    # Generate key insights
                    st.markdown("### Insights Estrat√©gicos")
                    
                    # Economic insight
                    eco_df = corr_df[corr_df['Categoria'] == 'Indicador Econ√¥mico']
                    if not eco_df.empty:
                        top_eco = eco_df.iloc[0]
                        direction = "positiva" if top_eco['Correla√ß√£o'] > 0 else "negativa"
                        impact = "aumento" if top_eco['Correla√ß√£o'] > 0 else "redu√ß√£o"
                        
                        st.info(f"""
                        **Economia:** O indicador {top_eco['Fator Formatado']} tem a correla√ß√£o {direction} mais forte ({top_eco['Correla√ß√£o']:.2f}) 
                        com a audi√™ncia da Globo, sugerindo que seu {impact} est√° associado a {'maior' if top_eco['Correla√ß√£o'] > 0 else 'menor'} 
                        consumo de TV Linear Globo.
                        
                        **Implica√ß√£o:** Monitorar este indicador pode ajudar a prever flutua√ß√µes na audi√™ncia e adaptar estrat√©gias comerciais 
                        e de programa√ß√£o de acordo.
                        """)
                    
                    # Globo programs
                    globo_progs = corr_df[corr_df['Categoria'] == 'Programa Globo']
                    if not globo_progs.empty:
                        top_prog = globo_progs.iloc[0]
                        
                        st.success(f"""
                        **Programa√ß√£o Pr√≥pria:** O programa {top_prog['Fator Formatado']} tem o maior impacto positivo 
                        na audi√™ncia geral da Globo (correla√ß√£o: {top_prog['Correla√ß√£o']:.2f}).
                        
                        **Implica√ß√£o:** Este tipo de conte√∫do representa um ponto forte da emissora e deve ser 
                        potencializado em termos de investimento e marketing.
                        """)
                    
                    # Competition threat
                    competitors = corr_df[(corr_df['Categoria'].isin(['Programa Concorrente', 'G√™nero Concorrente'])) & (corr_df['Correla√ß√£o'] < 0)]
                    if not competitors.empty:
                        top_threat = competitors.iloc[0]
                        
                        st.error(f"""
                        **Amea√ßa Competitiva:** {top_threat['Fator Formatado']} √© o conte√∫do concorrente que mais 
                        reduz a audi√™ncia da Globo (correla√ß√£o: {top_threat['Correla√ß√£o']:.2f}).
                        
                        **Implica√ß√£o:** Este √© um ponto de vulnerabilidade da Globo. Considerar estrat√©gias como 
                        contraprograma√ß√£o ou fortalecimento de conte√∫dos similares no portf√≥lio pr√≥prio pode ser necess√°rio.
                        """)
                    
                    # Generate an overall business recommendation
                    st.markdown("### Recomenda√ß√£o para o Neg√≥cio")
                    
                    # Organize factors by correlation type
                    pos_factors = corr_df[corr_df['Correla√ß√£o'] > 0.3].head(3)
                    neg_factors = corr_df[(corr_df['Correla√ß√£o'] < -0.3) & (corr_df['Categoria'].isin(['Programa Concorrente', 'G√™nero Concorrente']))].head(3)
                    
                    pos_factors_list = ", ".join([f"{row['Fator Formatado']} ({row['Correla√ß√£o']:.2f})" for _, row in pos_factors.iterrows()])
                    neg_factors_list = ", ".join([f"{row['Fator Formatado']} ({row['Correla√ß√£o']:.2f})" for _, row in neg_factors.iterrows()])
                    
                    st.success(f"""
                    **Estrat√©gia Baseada nos Dados:**
                    
                    Com base na an√°lise de correla√ß√£o entre fatores externos e audi√™ncia da TV Globo, recomendamos:
                    
                    1. **Potencializar fatores positivos:** Aproveitar e amplificar a presen√ßa de {pos_factors_list}, que demonstraram forte correla√ß√£o positiva com a audi√™ncia da Globo.
                    
                    2. **Mitigar amea√ßas competitivas:** Desenvolver estrat√©gias de contraprograma√ß√£o para {neg_factors_list}, que est√£o efetivamente "roubando" audi√™ncia da Globo.
                    
                    3. **Monitorar continuamente:** Estabelecer um sistema de monitoramento cont√≠nuo destes fatores para antecipar flutua√ß√µes na audi√™ncia e adaptar a programa√ß√£o e estrat√©gias de marketing de acordo.
                    
                    4. **Adaptar ao contexto econ√¥mico:** Considerando os indicadores econ√¥micos com maior correla√ß√£o, ajustar a grade de programa√ß√£o e esfor√ßos comerciais para maximizar a audi√™ncia conforme as condi√ß√µes do mercado.
                    """)
                else:
                    st.warning("N√£o foi poss√≠vel calcular correla√ß√µes significativas com os dados dispon√≠veis.")
            else:
                st.warning("N√£o foram encontrados fatores externos para an√°lise.")
        else:
            st.warning("Dados de audi√™ncia TV n√£o est√£o dispon√≠veis para an√°lise.")

    # 9. Final notes - always show
    with st.expander("Informa√ß√µes sobre a an√°lise de fatores externos"):
        st.markdown("""
        ### Fonte dos Dados

        **Indicadores Econ√¥micos**: Os dados econ√¥micos s√£o obtidos de fontes oficiais como o Banco Central do Brasil e o IBGE.

        **Grade de Programa√ß√£o**: Os dados da grade s√£o obtidos a partir das informa√ß√µes oficiais de programa√ß√£o de cada emissora.

        **Eventos Isolados**: Eventos pontuais identificados e categorizados manualmente com base em calend√°rios e not√≠cias relevantes.

        **Volume Social**: Os dados de volume social s√£o obtidos via APIs de plataformas de redes sociais, com foco em termos relacionados √† m√≠dia e entretenimento.

        ### Considera√ß√µes Metodol√≥gicas

        1. **Correla√ß√£o n√£o implica causalidade**: Embora identifiquemos correla√ß√µes entre fatores externos e audi√™ncia, isso n√£o necessariamente indica uma rela√ß√£o causal. Outros fatores n√£o observados podem estar influenciando ambas as vari√°veis.

        2. **Limita√ß√µes temporais**: A an√°lise considera apenas o per√≠odo coberto pelos dados dispon√≠veis, que pode n√£o representar todos os ciclos econ√¥micos ou sazonalidades.

        3. **Competi√ß√£o por audi√™ncia**: Correla√ß√µes negativas entre programas de emissoras concorrentes e a audi√™ncia da Globo indicam potencial "roubo" de audi√™ncia, mas √© importante considerar que o universo total de telespectadores n√£o √© fixo.

        4. **Modelo linear**: O modelo explicativo integrado assume rela√ß√µes lineares entre fatores externos e audi√™ncia, o que pode n√£o capturar completamente rela√ß√µes mais complexas.
        
        5. **Granularidade dos dados**: A an√°lise hor√°ria permite maior precis√£o ao examinar o impacto imediato de eventos, enquanto a an√°lise di√°ria ou semanal captura tend√™ncias mais amplas.
        
        6. **Compara√ß√µes v√°lidas**: Para cada an√°lise, consideramos apenas os per√≠odos em que existem dados v√°lidos para todas as vari√°veis envolvidas, garantindo que as compara√ß√µes sejam consistentes e representativas.
        """)